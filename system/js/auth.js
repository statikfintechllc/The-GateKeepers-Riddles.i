// GitHub Authentication Module
// Handles GitHub Personal Access Token authentication for riddle requests

const GITHUB_TOKEN_KEY = 'github_token';
const GITHUB_REPO_OWNER = 'statikfintechllc';
const GITHUB_REPO_NAME = 'The-GateKeepers-Riddles.i';

// Check if user is authenticated
export function isAuthenticated() {
    const token = localStorage.getItem(GITHUB_TOKEN_KEY);
    return token !== null && token.trim() !== '';
}

// Get the stored GitHub token
export function getGitHubToken() {
    return localStorage.getItem(GITHUB_TOKEN_KEY);
}

// Save GitHub token
export function saveGitHubToken(token) {
    if (!token || token.trim() === '') {
        throw new Error('Token cannot be empty');
    }
    localStorage.setItem(GITHUB_TOKEN_KEY, token.trim());
}

// Clear GitHub token (logout)
export function clearGitHubToken() {
    localStorage.removeItem(GITHUB_TOKEN_KEY);
}

// Validate token format (basic check)
// Supports: 'ghp_' (classic PAT), 'github_pat_' (fine-grained PAT), 'gho_' (OAuth), 'ghs_' (App token)
export function isValidTokenFormat(token) {
    if (!token || typeof token !== 'string') {
        return false;
    }
    
    const trimmedToken = token.trim();
    return (
        trimmedToken.startsWith('ghp_') ||         // Classic PAT
        trimmedToken.startsWith('github_pat_') ||  // Fine-grained PAT
        trimmedToken.startsWith('gho_') ||         // OAuth token
        trimmedToken.startsWith('ghs_')            // GitHub App token
    );
}

// Verify token by making a test API call
export async function verifyToken(token) {
    try {
        const response = await fetch('https://api.github.com/user', {
            headers: {
                'Authorization': `Bearer ${token}`,
                'Accept': 'application/vnd.github.v3+json'
            }
        });
        
        return response.ok;
    } catch (error) {
        console.error('Error verifying token:', error);
        return false;
    }
}

// Create a GitHub pull request for a riddle request
export async function createRiddleRequestPullRequest() {
    const token = getGitHubToken();
    if (!token) {
        throw new Error('Not authenticated');
    }

    const headers = {
        'Authorization': `Bearer ${token}`,
        'Accept': 'application/vnd.github+json'
    };

    try {
        // Discover default branch
        const repoResponse = await fetch(`https://api.github.com/repos/${GITHUB_REPO_OWNER}/${GITHUB_REPO_NAME}`, {
            headers
        });

        if (!repoResponse.ok) {
            throw new Error('Failed to load repository info');
        }

        const repoData = await repoResponse.json();
        const baseBranch = repoData.default_branch || 'master';

        // Get base branch SHA
        const refResponse = await fetch(`https://api.github.com/repos/${GITHUB_REPO_OWNER}/${GITHUB_REPO_NAME}/git/ref/heads/${baseBranch}`, {
            headers
        });

        if (!refResponse.ok) {
            throw new Error('Failed to read base branch reference');
        }

        const refData = await refResponse.json();
        const baseSha = refData?.object?.sha;

        if (!baseSha) {
            throw new Error('Base branch SHA not available');
        }

        // Create request branch
        const timestamp = Date.now();
        const branchName = `riddle-request/${timestamp}`;

        const createRefResponse = await fetch(`https://api.github.com/repos/${GITHUB_REPO_OWNER}/${GITHUB_REPO_NAME}/git/refs`, {
            method: 'POST',
            headers: {
                ...headers,
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({
                ref: `refs/heads/${branchName}`,
                sha: baseSha
            })
        });

        if (!createRefResponse.ok) {
            let errorMessage = 'Failed to create request branch';
            try {
                const errorData = await createRefResponse.json();
                errorMessage = errorData.message || errorMessage;
            } catch (e) {
                // ignore JSON parse errors
            }
            throw new Error(errorMessage);
        }

        // Add request marker file so the PR has content
        const requestPath = `.github/riddle-requests/request-${timestamp}.md`;
        const requestContent = [
            '# ðŸ¤– Automated Riddle Request',
            '',
            'This request was generated by the interactive game UI.',
            '',
            `- Requested: ${new Date(timestamp).toISOString()}`,
            '- Flow: PR-based request (refresh feed in ~10 minutes after merge)',
            '',
            'Please run the Riddle Finder Agent to generate and merge a new riddle.'
        ].join('\n');

        const fileResponse = await fetch(`https://api.github.com/repos/${GITHUB_REPO_OWNER}/${GITHUB_REPO_NAME}/contents/${encodeURIComponent(requestPath)}`, {
            method: 'PUT',
            headers: {
                ...headers,
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({
                message: `chore: add riddle request ${timestamp}`,
                content: btoa(unescape(encodeURIComponent(requestContent))),
                branch: branchName
            })
        });

        if (!fileResponse.ok) {
            let errorMessage = 'Failed to add request file';
            try {
                const errorData = await fileResponse.json();
                errorMessage = errorData.message || errorMessage;
            } catch (e) {
                // ignore JSON parse errors
            }
            throw new Error(errorMessage);
        }

        // Create pull request using the template content
        const prBody = [
            '## ðŸ¤– Automated Riddle Request',
            '',
            'This PR was opened by the game UI. Please allow ~10 minutes for automation to complete and refresh the feed afterwards.',
            '',
            '- [ ] Riddle Finder Agent triggered',
            '- [ ] Riddle file added and registry updated',
            '- [ ] App refreshed',
            '',
            '*Generated automatically from the riddle request interface.*'
        ].join('\n');

        const prResponse = await fetch(`https://api.github.com/repos/${GITHUB_REPO_OWNER}/${GITHUB_REPO_NAME}/pulls`, {
            method: 'POST',
            headers: {
                ...headers,
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({
                title: 'New Riddle Requested',
                head: branchName,
                base: baseBranch,
                body: prBody,
                draft: false
            })
        });

        if (!prResponse.ok) {
            let errorMessage = 'Failed to create pull request';
            try {
                const errorData = await prResponse.json();
                errorMessage = errorData.message || errorMessage;
            } catch (e) {
                // ignore JSON parse errors
            }
            throw new Error(errorMessage);
        }

        const pullRequest = await prResponse.json();

        // Try to proactively assign the Copilot coding agent, add helpful labels, and post a summon comment
        // so that Copilot starts a coding-agent session instead of acting only as a reviewer.
        // We await this so the UI knows the annotation was attempted before returning.
        await (async () => {
            try {
                const prNumber = pullRequest.number;
                const issueBase = `https://api.github.com/repos/${GITHUB_REPO_OWNER}/${GITHUB_REPO_NAME}/issues/${prNumber}`;

                // 1) Add assignee(s) - try a couple of candidate logins that may represent the Copilot agent
                const assignees = ['Copilot', 'copilot-swe-agent'];
                for (const a of assignees) {
                    try {
                        const assignResp = await fetch(`${issueBase}/assignees`, {
                            method: 'POST',
                            headers: {
                                ...headers,
                                'Content-Type': 'application/json'
                            },
                            body: JSON.stringify({ assignees: [a] })
                        });

                        if (assignResp.ok) {
                            console.log(`Assigned ${a} to PR #${prNumber}`);
                            break;
                        } else {
                            try {
                                const errData = await assignResp.json();
                                const msg = errData && errData.message ? errData.message : `${assignResp.status} ${assignResp.statusText}`;
                                console.warn(`Could not assign ${a}: ${msg}`);
                            } catch (_) {
                                console.warn(`Could not assign ${a}: ${assignResp.status} ${assignResp.statusText}`);
                            }
                        }
                    } catch (errAssign) {
                        console.warn('Assign request failed for', a, String(errAssign));
                    }
                }

                // 2) Add labels so workflows and maintainers can easily find agent-requested riddle PRs
                try {
                    const labelsResp = await fetch(`${issueBase}/labels`, {
                        method: 'POST',
                        headers: {
                            ...headers,
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify(['copilot-agent-request', 'riddle-request'])
                    });

                    if (labelsResp.ok) {
                        console.log(`Added labels to PR #${prNumber}`);
                    } else {
                        try {
                            const errData = await labelsResp.json();
                            const msg = errData && errData.message ? errData.message : `${labelsResp.status} ${labelsResp.statusText}`;
                            console.warn('Could not add labels:', msg);
                        } catch (_) {
                            console.warn('Could not add labels:', `${labelsResp.status} ${labelsResp.statusText}`);
                        }
                    }
                } catch (errLabels) {
                    console.warn('Labels request failed:', String(errLabels));
                }

                // 3) Check for an existing summon marker in comments. Do not post comments â€” avoid spam.
                try {
                    const marker = 'Copilot coding agent summoned via comment';
                    const commentsResp = await fetch(`${issueBase}/comments`, { headers });
                    let already = false;
                    if (commentsResp.ok) {
                        const comments = await commentsResp.json();
                        for (const c of comments) {
                            if (c && typeof c.body === 'string' && c.body.includes(marker)) {
                                already = true;
                                break;
                            }
                        }
                    }

                    if (already) {
                        console.log('Summon comment already exists for PR #' + prNumber);
                    }
                } catch (errComment) {
                    console.warn('Comment request failed:', String(errComment));
                }

            } catch (err) {
                console.warn('Error annotating PR for agent request:', String(err));
            }
        })();

        // Check rate limit from headers
        const remaining = prResponse.headers.get('X-RateLimit-Remaining');
        const reset = prResponse.headers.get('X-RateLimit-Reset');
        if (remaining !== null && parseInt(remaining, 10) < 10) {
            let resetDate = null;
            if (reset) {
                resetDate = new Date(parseInt(reset, 10) * 1000);
            }
            console.warn(`GitHub API rate limit warning: ${remaining} requests remaining until ${resetDate ? resetDate.toLocaleTimeString() : 'unknown'}`);
        }

        return pullRequest;
    } catch (error) {
        console.error('Error creating riddle request pull request:', error);
        throw error;
    }
}

// Create a GitHub issue to request a new AI-curated riddle (preferred flow when user is signed-in)
export async function createRiddleRequestIssue() {
    const token = getGitHubToken();
    if (!token) {
        throw new Error('Not authenticated');
    }

    const headers = {
        'Authorization': `Bearer ${token}`,
        'Accept': 'application/vnd.github+json'
    };

    try {
        const timestamp = Date.now();

        const title = 'New Riddle Requested';
        const body = [
            '## ðŸ¤– Automated Riddle Request (Issue)',
            '',
            'This issue was opened by the interactive game UI requesting that the Riddle Finder Agent create a new riddle via a code agent PR.',
            '',
            `- Requested: ${new Date(timestamp).toISOString()}`,
            '',
            'Please run the Riddle Finder Agent to find or generate a high-quality riddle, add the riddle file to `system/riddles/`, update `system/riddles/riddles.js`, and open a PR for review.',
            '',
            'Assignments: Copilot agents will be asked to take ownership of creating the PR and processing it. A maintainer should review the Notes section in `.github/agents/riddle-finder.agent.md` to ensure quality.',
            '',
            '*Generated automatically from the riddle request interface.*'
        ].join('\n');

        // Assign three agent accounts (Copilot variants) and a human reviewer for Notes
        const assignees = ['Copilot', 'copilot-swe-agent', 'copilot-pull-request-reviewer', 'statikfintechllc'];
        const labels = ['agent-request', 'riddle-request', 'enhancement'];

        // Attempt to create the issue with assignees (preferred) and fall back to creating without them if the token cannot assign
        const createBodyWithAssignees = { title, body, labels, assignees };

        let issueResponse = await fetch(`https://api.github.com/repos/${GITHUB_REPO_OWNER}/${GITHUB_REPO_NAME}/issues`, {
            method: 'POST',
            headers: {
                ...headers,
                'Content-Type': 'application/json'
            },
            body: JSON.stringify(createBodyWithAssignees)
        });

        let issue;
        if (!issueResponse.ok) {
            // If assign-at-create failed (common when the PAT can't add certain assignees), fall back to creating without assignees
            try {
                const err = await issueResponse.json();
                console.warn('Create with assignees failed:', err.message || err);
            } catch (e) {
                // ignore
            }

            const fallbackBody = { title, body, labels };
            issueResponse = await fetch(`https://api.github.com/repos/${GITHUB_REPO_OWNER}/${GITHUB_REPO_NAME}/issues`, {
                method: 'POST',
                headers: {
                    ...headers,
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify(fallbackBody)
            });

            if (!issueResponse.ok) {
                let errorMessage = 'Failed to create issue (with and without assignees)';
                try {
                    const errorData = await issueResponse.json();
                    errorMessage = errorData.message || errorMessage;
                } catch (e) {}
                throw new Error(errorMessage);
            }

            issue = await issueResponse.json();
        } else {
            issue = await issueResponse.json();
        }

        // Attempt to add assignees separately so the main create call succeeds even if assignment fails
        (async () => {
            try {
                const issueNumber = issue.number;
                // Try to add assignees; if this fails, log but do not throw
                const assignResp = await fetch(`https://api.github.com/repos/${GITHUB_REPO_OWNER}/${GITHUB_REPO_NAME}/issues/${issueNumber}/assignees`, {
                    method: 'POST',
                    headers: {
                        ...headers,
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ assignees })
                });

                if (assignResp.ok) {
                    console.log('Assigned agents to issue #' + issue.number);
                } else {
                    try {
                        const errData = await assignResp.json();
                        console.warn('Failed to add assignees:', errData && errData.message ? errData.message : `${assignResp.status} ${assignResp.statusText}`);
                    } catch (_) {
                        console.warn('Failed to add assignees: ' + assignResp.status + ' ' + assignResp.statusText);
                    }
                }
            } catch (err) {
                console.warn('Assignee addition failed:', String(err));
            }

            // Try to ensure the labels exist (POST labels is idempotent)
            try {
                const issueNumber = issue.number;
                const labelsResp = await fetch(`https://api.github.com/repos/${GITHUB_REPO_OWNER}/${GITHUB_REPO_NAME}/issues/${issueNumber}/labels`, {
                    method: 'POST',
                    headers: {
                        ...headers,
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(labels)
                });

                if (labelsResp.ok) console.log('Labels set for issue #' + issue.number);
                else console.warn('Failed to set labels for issue #' + issue.number);
            } catch (err) {
                console.warn('Label addition failed:', String(err));
            }

            // Do not post comments to avoid spamming issues â€” assignments and labels are sufficient
        })();

        return issue;
    } catch (error) {
        console.error('Error creating riddle request issue:', error);
        throw error;
    }
}

// Open GitHub PR creation page (fallback if API fails)
export function openGitHubPullRequestTemplate() {
    // Fallback: open the issue-based riddle request template so users without API tokens can file the request
    const issueUrl = `https://github.com/${GITHUB_REPO_OWNER}/${GITHUB_REPO_NAME}/issues/new?template=riddle_request.md&title=New+Riddle+Requested&labels=agent-request,riddle-request,enhancement&assignees=Copilot,copilot-swe-agent,statikfintechllc,copilot-pull-request-reviewer`;
    window.open(issueUrl, '_blank');
}

// Navigate to login page
export function redirectToLogin() {
    // Determine if we're in root or system directory
    const currentPath = window.location.pathname;
    if (currentPath.includes('/system/')) {
        // We're in system directory, go up one level
        window.location.href = '../index.html';
    } else {
        // We're in root, just refresh to index.html
        window.location.href = 'index.html';
    }
}

// Navigate to app (riddle page)
export function redirectToApp() {
    // Determine if we're in root or system directory
    const currentPath = window.location.pathname;
    if (currentPath.includes('/system/')) {
        // We're already in system, just go to riddle.html
        window.location.href = 'riddle.html';
    } else {
        // We're in root, navigate to system/riddle.html
        window.location.href = 'system/riddle.html';
    }
}
